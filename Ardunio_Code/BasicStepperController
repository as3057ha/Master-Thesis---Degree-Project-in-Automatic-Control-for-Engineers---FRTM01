#include <stdbool.h>
#include <Arduino.h>

// Define the connection pins
const int dirPin = 8; // DIR- connected to pin 8
const int pulPin = 9; // PUL- connected to pin 9

// Define motor control variables
const int stepsPerRevolution = 800; // Number of pulses per revolution
const int baseRpm = 40; // Base RPM


// Define physical variables
const float NUMBER_TEETH_A = 32;
const float NUMBER_TEETH_B = 60;
const float FEEDING_RADIUS = (30.0 - 1.427)*0.001; // In meters 

// Define control variables
const double STEPS_PER_REVOLUTION = 800; // Set this to the number of pulses per revolution as per DIP switch settings
const double SAMPLE_TIME = 50; // In miliseconds

// Mock data
float vectorData[] = {
    0.009359928372335902,0.03638185375370186,0.09325720705333092,0.13927239806346536,0.19323586187029457,0.2620708178503811,0.29315063982769296,0.3488900271237711,0.38079455255917793,0.445191544375395,0.5039192239572305,0.4988673183973963,0.510765491008229,0.5017196892340765,0.514772276314553,0.498938678758812,0.5107059696198987,0.4949068549209342,0.5065431825475957,0.5115436237837065,0.4961576336201521,0.49583723970585114,0.0024730499707425885
};
int currentIndex = 0;

int totalElements = sizeof(vectorData) / sizeof(vectorData[0]);

void setup() {
  pinMode(dirPin, OUTPUT);
  pinMode(pulPin, OUTPUT);
  digitalWrite(dirPin, LOW);
  digitalWrite(pulPin, LOW);
  Serial.begin(9600); // Start serial communication for debugging
}

void loop() {
  // Adjust RPM with noise every 50ms
  unsigned long lastUpdateTime = 0; // Last time the RPM was updated
  while(true) { // Continuous loop
    if (millis() - lastUpdateTime >= 50) { // Check if it's time to update the RPM
      lastUpdateTime = millis();
      double vTcp = readVTcp();
      double rpm = calculateRPM(vTcp);
      int noisyRpm = rpm; // Add noise to the base RPM
      Serial.println("RPM " + (String) (noisyRpm));
      rotateMotorWithNoise(noisyRpm);
    }
  }
}

void makeSingleStep(int rpm) {
  digitalWrite(pulPin, HIGH);
  delayMicroseconds(5);
  digitalWrite(pulPin, LOW);
  delayMicroseconds(calculatePulseDelay(rpm));
}

long calculatePulseDelay(int rpm) {
  // Calculate the delay between pulses to achieve the desired RPM
  return 60L * 1000000L / stepsPerRevolution / rpm;
}

void rotateMotorWithNoise(int rpm) {
  digitalWrite(dirPin, HIGH); // Set the direction
  makeSingleStep(rpm); // Make a single step with the current noisy RPM
}

int generateRpmNoise() {
  // Generate random noise between -5 and +5
  return random(-5, 6); // random(min, max) generates a number between min and inclusive max-1
}

double readVTcp() {
    // Check if all elements have been read
    if (currentIndex >= totalElements) {
        // Stop the main loop
        while (true) {
            // Do nothing, just keep the main loop running
        }
    }

    // Return the current value and update the index for the next call
    float currentValue = vectorData[currentIndex];
    currentIndex++;
    return currentValue;
}

double calculateRPM(double vTcp) {
  return vTcp*60*NUMBER_TEETH_B/(FEEDING_RADIUS*2*PI*NUMBER_TEETH_A);}

